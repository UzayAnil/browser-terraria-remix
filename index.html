<!--
    TODO:
        [ ] Add an inventory section.
        [ ] Add a way for the user to save screenshots using the REIMG script on this thread ( https://stackoverflow.com/questions/10673122/how-to-save-canvas-as-an-image-with-canvas-todataurl ).
        [ ] Make it so that the trees are randomly rotated, or are different sprites for randomization.
        [ ] Add buttons so that its playable on mobile devices.
        [ ] Add a credit screen.
        [ ] Add caves.
        [ ] Fix the gravity.
-->
<!DOCTYPE HTML>
<html lang = 'en'>
    <head>
        <meta charset = 'utf-8'/>
        <title>Terraria Browser Remix</title>
        <style>
            @font-face{font-family:__local__pixelsplitter__;src:url('./utils/fonts/pixelsplitter.ttf');}
            body{font-family:__local__pixelsplitter__;background-color:white;}
            .daylightAffectedSprite{background-color:black;opacity:1;}
            .gameBlockSprite{width:20px;height:20px;}
            .gameCharacterSprite{width:20px;height:40px;}
            #gamecanvas{background-color:#91f8ff;position:absolute;top:0px;left:0px;width:100%;height:100%;}
            .hiddenImage{display:none;}
            .nocursor{cursor:none;}
        </style>
    </head>
    <body onkeydown = 'handleKeyDown(event.keyCode);' oncontextmenu = 'handleCursorEvent("right");return false;' class = 'nocursor' onclick = 'handleCursorEvent("left");'>
        <img src = './utils/ingame-images/character-sprite.png' id = 'sprites.charactersprite' class = 'daylightAffectedSprite gameCharacterSprite hiddenImage'/>
        <img src = './utils/ingame-images/dirt-block.png' id = 'sprites.dirtblocksprite' class = 'daylightAffectedSprite gameBlockSprite hiddenImage'/>
        <img src = './utils/ingame-images/error-block.png' id = 'sprites.errorblocksprite' class = 'daylightAffectedSprite gameBlockSprite hiddenImage'/>
        <img src = './utils/ingame-images/grass-block.png' id = 'sprites.grassblocksprite' class = 'daylightAffectedSprite gameBlockSprite hiddenImage'/>
        <img src = './utils/ingame-images/stone-block.png' id = 'sprites.stoneblocksprite' class = 'daylightAffectedSprite gameBlockSprite hiddenImage'/>
        <img src = './utils/ingame-images/grass-overlay.png' id = 'sprites.grassoverlaysprite' class = 'daylightAffectedSprite gameBlockSprite hiddenImage'/>
        <img src = './utils/ingame-images/grass-overlay-2.png' id = 'sprites.grassoverlaysprite2' class = 'daylightAffectedSprite gameBlockSprite hiddenImage'/>
        <img src = './utils/ingame-images/crosshair.png' id = 'sprites.crosshair' class = 'hiddenImage'/>
        <img src = './utils/ingame-images/tree-sprite.png' id = 'sprites.treesprite1' class = 'daylightAffectedSprite hiddenImage'/>
        <img src = './utils/ingame-images/tree-sprite2.png' id = 'sprites.treesprite2' class = 'daylightAffectedSprite hiddenImage'/>
        <img src = './utils/ingame-images/shrubbery-overlay.png' id = 'sprites.shrubberyoverlaysprite' class = 'daylightAffectedSprite gameBlockSprite hiddenImage'/>
        <img src = './utils/ingame-images/startscreen-art.png' id = 'sprites.startscreenart' class = 'hiddenImage'/>
        <img src = './utils/ingame-images/crosshair-block-selection-outline.png' id = 'sprites.crosshairselectionindicator' class = 'hiddenImage'/>
        <img src = './utils/ingame-images/inventory-slot-background.png' id = 'sprites.inventoryslotbg' class = 'hiddenImage'/>
        <img src = './utils/ingame-images/inventory-slot-selection-indicator.png' id = 'sprites.inventoryslotselected' class = 'hiddenImage'/>
        <img src = './utils/ingame-images/cloud1.png' id = 'sprites.cloud1' class = 'daylightAffectedSprite hiddenImage'/>
        <img src = './utils/ingame-images/cloud2.png' id = 'sprites.cloud2' class = 'daylightAffectedSprite hiddenImage'/>
        <img src = './utils/ingame-images/sun.png' id = 'sprites.sun' class = 'daylightAffectedSprite hiddenImage'/>
        <img src = './utils/ingame-images/berry-bush.png' id = 'sprites.berrybushsprite' class = 'daylightAffectedSprite gameBlockSprite hiddenImage'/>
        <img src = './utils/ingame-images/berry-bush-2.png' id = 'sprites.berrybush2sprite' class = 'daylightAffectedSprite gameBlockSprite hiddenImage'/>
        <img src = './utils/ingame-images/controls-button.png' id = 'sprites.controlsbutton' class = 'hiddenImage'/>
        <img src = './utils/ingame-images/credits-button.png' id = 'sprites.creditsbutton' class = 'hiddenImage'/>
        <canvas id = 'gamecanvas'><p>Error showing canvas.</p></canvas>
        <script>
            console.log('Press the "[" button to toggle the debug overlay.')
            function handleCursorEvent (button) {
                cursorEventHandled = {
                    'handled':false,
                    'position':mouseCoords,
                    'button':button
                }
            }
            function getRandomInt(min, max) {
                return Math.floor(Math.random() * (max - min + 1) + min);
            }
            function getTouchingBlockCoord() {
                return yCoordinateTouching = Math.floor(gameData['playerData']['position'][1]);
            }
            function getIsTouchingBlock() {
                var isTouchingBlock = false;
                var yCoordinateTouching = Math.floor(gameData['playerData']['position'][1]);
                try {
                    blockData = gameData['terrainData'][Math.floor(gameData['playerData']['position'][0])]['blockData'][yCoordinateTouching];
                    if (blockData != undefined && blockData['isSolid'] == true) {
                        isTouchingBlock = true;
                    }
                } catch (e) {
                }
                return isTouchingBlock;
            }
            function getMaxBlockYCoord() {
                var maxYCoord = 0;
                var blocksInRow = gameData['terrainData'][Math.floor(gameData['playerData']['position'][0])]['blockData'];
                var blocksInRowKeys = Object.keys(blocksInRow);
                var blocksInRowKeysInts = [];
                for (i = 0;i < blocksInRowKeys.length;i++) {
                    if (blocksInRow[blocksInRowKeys[i]]['isSolid']) {
                        blocksInRowKeysInts.push(parseInt(blocksInRowKeys[i]));
                    }
                }
                maxYCoord = Math.max.apply(null, blocksInRowKeysInts);
                return maxYCoord;
            }
            function getMaxBlockYCoordForGivenXCoord(xCoord) {
                var maxYCoord = 0;
                var blocksInRow = gameData['terrainData'][Math.floor(xCoord)]['blockData'];
                var blocksInRowKeys = Object.keys(blocksInRow);
                var blocksInRowKeysInts = [];
                for (i = 0;i < blocksInRowKeys.length;i++) {
                    if (blocksInRow[blocksInRowKeys[i]]['isSolid']) {
                        blocksInRowKeysInts.push(parseInt(blocksInRowKeys[i]));
                    }
                }
                maxYCoord = Math.max.apply(null, blocksInRowKeysInts);
                return maxYCoord;
            }
            function handleKeyDown(keyCode) {
                if (gameScreenMode == 'ingame') {
                    isTouchingBlock = getIsTouchingBlock();
                    if (keyCode == 68) {
                        gameData['playerData']['position'][0] += 0.5;
                    } else if (keyCode == 65) {
                        gameData['playerData']['position'][0] -= 0.5;
                    } else if (keyCode == 87 && isTouchingBlock) {
                        gameData['playerData']['position'][1] += 2;
                    } else if (keyCode == 219) {
                        infoDebugMode = !infoDebugMode;
                    } else if (keyCode == 221) {
                        gridDebugMode = !gridDebugMode;
                    } else if (keyCode == 82) {
                        gameData['playerData']['position'] = [0, 0];
                    } else if (keyCode == 69) {
                        inventory['selectedSlot'] -= 1;
                        if (inventory['selectedSlot'] < 0) {
                            inventory['selectedSlot'] = 0;
                        }
                    } else if (keyCode == 81) {
                        inventory['selectedSlot'] += 1;
                        if (inventory['selectedSlot'] > Object.keys(inventory['items']).length - 1) {
                            inventory['selectedSlot'] = Object.keys(inventory['items']).length - 1;
                        }
                    }
                } else if (gameScreenMode.split(':')[0] == 'menu') {
                    currentMenuSelected = parseInt(gameScreenMode.split(':')[1]);
                    if (keyCode == 38) {
                        currentMenuSelected -= 1;
                    } else if (keyCode == 40) {
                        currentMenuSelected += 1;
                    }
                    if (currentMenuSelected > menuData['menuItems'].length - 1) {
                        currentMenuSelected = 0;
                    } else if (currentMenuSelected < 0) {
                        currentMenuSelected = menuData['menuItems'].length - 1;
                    }
                    menuData['currentSelectedMenuButton'] = currentMenuSelected;
                    gameScreenMode = 'menu:' + String(menuData['currentSelectedMenuButton'])
                }
                if (keyCode == 27 && gameScreenMode != 'loadingterraingen') {
                    if (gameScreenMode.split(':')[0] != 'menu') {
                        gameScreenMode = 'menu:0';
                    } else {
                        gameScreenMode = 'ingame';
                    }
                }
                if (keyCode == 220 && gameScreenMode != 'loadingterraingen') {
                    if (gameScreenMode == 'screenshotmode') {
                        gameScreenMode = 'ingame';
                    } else {
                        gameScreenMode = 'screenshotmode';
                    }
                }
            }
            function toggleScreenshotMode1(mode) {
                showCharactersOnScreen = mode;
                showCrosshairOnScreen = mode;
                showInventoryOnScreen = mode;
            }
            function generateTerrainChunk(minXCoord, maxXCoord, maxHeight, minHeight, worldXMinBorder, worldXMaxBorder, prevoiusGroundLevel, previousTerrainData, maxMountainHeight, minValleyDepth) {
                var groundLevel = prevoiusGroundLevel;
                for (xCoord = minXCoord;xCoord <= maxXCoord;xCoord++) {
                    if (!(xCoord in previousTerrainData) && xCoord >= worldXMinBorder && xCoord <= worldXMaxBorder) {
                        groundLevel += getRandomInt(-2, 1)
                        if (groundLevel < minValleyDepth) {
                            groundLevel = minValleyDepth;
                        } else if (groundLevel > maxMountainHeight) {
                            groundLevel = maxMountainHeight;
                        }
                        rowData = {
                            'maxHeight':0,
                            'blockData':{
                            }
                        };
                        rowData['maxHeight'] = parseInt(maxHeight);
                        for (yCoord = maxHeight;yCoord >= minHeight;yCoord--) {
                            if (groundLevel > maxHeight) {
                                groundLevel = maxHeight;
                            } else if (groundLevel < minHeight) {
                                groundLevel = minHeight;
                            }
                            distanceFromGroundLevel = groundLevel - yCoord;
                            isSolidBlock = true;
                            individualBlockData = {
                                'blockType':'errorblock',
                                'isSolid':true
                            }
                            if (yCoord <= groundLevel) {
                                if (distanceFromGroundLevel == 0) {
                                    blockType = 'grassblock';                                
                                } else if (distanceFromGroundLevel < getRandomInt(2, 5)) {
                                    blockType = 'dirtblock';
                                } else {
                                    blockType = 'stoneblock';
                                }
                                individualBlockData['blockType'] = blockType;
                                individualBlockData['isSolid'] = isSolidBlock;
                                rowData['blockData'][yCoord] = individualBlockData;
                            } else {
                                if (distanceFromGroundLevel == -1 && getRandomInt(0, 2) == 1) {
                                    grassTypes = ['grassoverlay', 'grassoverlay2'];
                                    blockType = grassTypes[getRandomInt(0, grassTypes.length - 1)];
                                    isSolidBlock = false;
                                    individualBlockData['blockType'] = blockType;
                                    individualBlockData['isSolid'] = isSolidBlock;
                                    rowData['blockData'][yCoord] = individualBlockData;
                                } else if (distanceFromGroundLevel == -1 && getRandomInt(0, 8) == 1) {
                                    blockType = 'shrubbery';
                                    isSolidBlock = false;
                                    individualBlockData['blockType'] = blockType;
                                    individualBlockData['isSolid'] = isSolidBlock;
                                    rowData['blockData'][yCoord] = individualBlockData;
                                } else if (distanceFromGroundLevel == -1 && getRandomInt(0, 4) == 1) {
                                    berryBushTypes = ['berrybush', 'berrybush2'];
                                    blockType = berryBushTypes[getRandomInt(0, berryBushTypes.length - 1)];
                                    isSolidBlock = false;
                                    individualBlockData['blockType'] = blockType;
                                    individualBlockData['isSolid'] = isSolidBlock;
                                    rowData['blockData'][yCoord] = individualBlockData;
                                } else if (distanceFromGroundLevel == -1 && getRandomInt(0, 6) == 1) {
                                    treeTypes = ['tree1', 'tree2'];
                                    blockType = treeTypes[getRandomInt(0, treeTypes.length - 1)];
                                    isSolidBlock = false;
                                    individualBlockData['blockType'] = blockType;
                                    individualBlockData['isSolid'] = isSolidBlock;
                                    rowData['blockData'][yCoord] = individualBlockData;
                                }
                            }
                        }
                        previousTerrainData[xCoord] = rowData;
                    }
                }
                return previousTerrainData;
            }
            function generateNewClouds(amount) {
                var clouds = [];
                var cloudTypes = ['cloud1', 'cloud2'];
                for (i = 0;i < amount;i++) {
                    var sizeModifier = getRandomInt(1, 3)
                    var cloudData = {
                        'position':[getRandomInt(0, 200), getRandomInt(0, 50)],
                        'cloudType':cloudTypes[getRandomInt(0, cloudTypes.length - 1)],
                        'size':[(3 * sizeModifier), (1 * sizeModifier)],
                        'opacity':(getRandomInt(20, 100) / 100)
                    };
                    clouds.push(cloudData);
                }
                return clouds;
            }
            var shaderMode = 'blocky-depth-shaders-1';
            var shaderPresets = {
                'blocky-depth-shaders-1':{
                    'maxLightPenetrationDepth':5,
                    'minDarkness':0.95,
                }
            };
            var cursorEventHandled = {
                'handled':null,
                'position':[NaN, NaN],
                'button':'none'
            };
            var showInventoryOnScreen = true;
            var showCrosshairOnScreen = true;
            var showCharactersOnScreen = true;
            var gameScreenMode = 'loadingterraingen';
            var terrainGenProgress = 0;
            var gridDebugMode = false; //disable for public release
            var infoDebugMode = false; //disable for public release
            var darknessLevel = 0;
            var canvas = document.getElementById('gamecanvas');
            var ctx = canvas.getContext('2d');
            var sprites = {
                'character':document.getElementById('sprites.charactersprite'),
                'dirtblock':document.getElementById('sprites.dirtblocksprite'),
                'errorblock':document.getElementById('sprites.errorblocksprite'),
                'grassblock':document.getElementById('sprites.grassblocksprite'),
                'stoneblock':document.getElementById('sprites.stoneblocksprite'),
                'grassoverlay':document.getElementById('sprites.grassoverlaysprite'),
                'grassoverlay2':document.getElementById('sprites.grassoverlaysprite2'),
                'crosshair':document.getElementById('sprites.crosshair'),
                'tree1':document.getElementById('sprites.treesprite1'),
                'tree2':document.getElementById('sprites.treesprite2'),
                'shrubbery':document.getElementById('sprites.shrubberyoverlaysprite'),
                'selectionindicator':document.getElementById('sprites.crosshairselectionindicator'),
                'inventoryslot':document.getElementById('sprites.inventoryslotbg'),
                'inventoryslotselected':document.getElementById('sprites.inventoryslotselected'),
                'cloud1':document.getElementById('sprites.cloud1'),
                'cloud2':document.getElementById('sprites.cloud2'),
                'sun':document.getElementById('sprites.sun'),
                'berrybush':document.getElementById('sprites.berrybushsprite'),
                'berrybush2':document.getElementById('sprites.berrybush2sprite'),
                'controlsbutton':document.getElementById('sprites.controlsbutton'),
                'creditsbutton':document.getElementById('sprites.creditsbutton')
            };
            var startScreenAssets = {
                'startscreenbg':{
                    'image':document.getElementById('sprites.startscreenart'),
                    'dimensions':[1800, 1800],
                    'keypresstostart':{
                        'keyCode':83
                    }
                }
            };
            var menuData = {
                'menuItems':['controls', 'credits'],
                'menuItemData':{
                    'controls':{
                        'spriteData':'controlsbutton',
                        'panelInfo':[
                            'W: Jump',
                            'A: Move left',
                            'D: Move right',
                            'R: Reset the player\'s position',
                            '[: Toggle text debug',
                            ']: Toggle grid debug',
                            '\\: Toggle screenshot mode',
                            'ESC: Toggle menu',
                            'UP-ARROW: Move up in the menu',
                            'DOWN-ARROW: Move down in the menu'
                        ]
                    },
                    'credits':{
                        'spriteData':'creditsbutton',
                        'panelInfo':[
                            'Textures/Sprites made by Toshi',
                            'Game programmed by Katznboyz'
                        ]
                    }
                },
                'currentSelectedMenuButton':0,
                'menuButtonSize':[300, 100]
            };
            var canvasBGColor = 'rgba(0, 0, 0, 1)';
            var blockSizeInPixels = 40;
            var running = true;
            var gameData = {
                'meta':{
                    'version':[0, 0, 1],
                },'terrainData':{
                },'playerData':{
                    'velocities':{
                        'x':0,
                        'y':0
                    },
                    'position':[0, 0]
                }, 'boundaryData':{
                    'xLeftBoundary':0,
                    'xRightBoundary':500,
                    'yTopBoundary':30,
                    'yBottomBoundary':-50,
                    'generationMinHeight':-20,
                    'generationMaxHeight':10,
                }
            };
            gameData['playerData']['position'][0] = Math.floor(gameData['boundaryData']['xRightBoundary'] / 2);
            var inventory = {
                'items':{
                    'stoneblock':10,
                    'dirtblock':10
                },
                'selectedSlot':0
            };
            var clouds = generateNewClouds(20);
            var mouseCoords = [Math.round(canvas.width / 2), Math.round(canvas.height / 2)];
            ctx.canvas.addEventListener('mousemove', function(event){
                mouseCoords = [event.clientX - ctx.canvas.offsetLeft, event.clientY - ctx.canvas.offsetTop];
            });
            var lastFps = 0;
            function drawLoop() {
                startTime = performance.now();
                canvas.width = canvas.clientWidth;
                canvas.height = canvas.clientHeight;
                canvasBGColor = 'rgba(0, 0, 0, ' + darknessLevel + ')';
                ctx.fillStyle = canvasBGColor;
                ctx.imageSmoothingEnabled = false;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                maxAmountOfBlocksOnXAxis = Math.floor(canvas.width / blockSizeInPixels) + 1;
                maxAmountOfBlocksOnYAxis = Math.floor(canvas.height / blockSizeInPixels) + 1;
                alphaDarkness = 1 - darknessLevel;
                alphaDarkness = alphaDarkness + (darknessLevel / 2);
                ctx.globalAlpha = alphaDarkness; //draw sprites below here
                if (gameScreenMode != 'ingame') {
                    toggleScreenshotMode1(false);
                } else {
                    toggleScreenshotMode1(true);
                }
                //ctx.drawImage(sprites['sun'], canvas.width - (canvas.width / 10) - ((gameData['playerData']['position'][0] / gameData['boundaryData']['xRightBoundary']) * canvas.width), canvas.height / 5, blockSizeInPixels * 3, blockSizeInPixels * 3);
                for (cloud = 0;cloud < clouds.length;cloud++) {
                    cloudData = clouds[cloud];
                    previousGlobalAlpha = ctx.globalAlpha;
                    ctx.globalAlpha = cloudData['opacity'];
                    offsetX = (gameData['playerData']['position'][0] / gameData['boundaryData']['xRightBoundary']) * canvas.width;
                    if (offsetX == Infinity || offsetX == -Infinity || offsetX == NaN) {
                        offsetX = 0;
                    }
                    ctx.drawImage(sprites[cloudData['cloudType']], ((cloudData['position'][0] / 100) * canvas.width) - offsetX, ((cloudData['position'][1] / 100) * canvas.height), cloudData['size'][0] * blockSizeInPixels, cloudData['size'][1] * blockSizeInPixels);
                    ctx.globalAlpha = previousGlobalAlpha;
                }
                positionFloatingPointLeftovers = [(gameData['playerData']['position'][0] - Math.floor(gameData['playerData']['position'][0])), (gameData['playerData']['position'][1] - Math.floor(gameData['playerData']['position'][1]))];
                characterSpriteXCoord = Math.ceil((maxAmountOfBlocksOnXAxis / 2));
                for (blockX = -characterSpriteXCoord + positionFloatingPointLeftovers[0] - 1;blockX < maxAmountOfBlocksOnXAxis - characterSpriteXCoord;blockX++) {
                    try {
                        rowData = gameData['terrainData'][Math.floor(blockX + gameData['playerData']['position'][0])];
                        drewCharacter = false;
                        if (rowData != undefined) {
                            for (YCoord in rowData['blockData']) {
                                centerYCoord = Math.floor(maxAmountOfBlocksOnYAxis / 2) * blockSizeInPixels;
                                individualData = rowData['blockData'][YCoord]['blockType'];
                                blockYCoord = (centerYCoord - (YCoord * blockSizeInPixels)) + (gameData['playerData']['position'][1] * blockSizeInPixels);
                                if (blockYCoord < maxAmountOfBlocksOnYAxis * blockSizeInPixels) {
                                    spriteName = sprites[individualData];
                                    if (spriteName == sprites['tree1'] || spriteName == sprites['tree2']) {
                                        ctx.drawImage(spriteName, (((blockX + characterSpriteXCoord) * blockSizeInPixels) + positionFloatingPointLeftovers[0]) - blockSizeInPixels, blockYCoord - (blockSizeInPixels * 3), (blockSizeInPixels * 3), (blockSizeInPixels * 4));
                                    } else {
                                        ctx.drawImage(spriteName, ((blockX + characterSpriteXCoord) * blockSizeInPixels) + positionFloatingPointLeftovers[0], blockYCoord, blockSizeInPixels, blockSizeInPixels);
                                        if (shaderMode == 'blocky-depth-shaders-1' && rowData['blockData'][YCoord]['isSolid']) {
                                            distanceFromTopSolidBlock = getMaxBlockYCoordForGivenXCoord(blockX + gameData['playerData']['position'][0]) - YCoord;
                                            previousFillColor = ctx.fillStyle;
                                            depthDarkness = 0;
                                            shaderData = shaderPresets[shaderMode];
                                            darknessStep = shaderData['minDarkness'] / shaderData['maxLightPenetrationDepth'];
                                            if (distanceFromTopSolidBlock <= shaderData['maxLightPenetrationDepth']) {
                                                depthDarkness = darknessStep * distanceFromTopSolidBlock;
                                            } else if (distanceFromTopSolidBlock > shaderData['maxLightPenetrationDepth']) {
                                                depthDarkness = shaderData['minDarkness'];
                                            }
                                            blockFillColor = 'rgba(0, 0, 0, ' + String(depthDarkness) + ')'
                                            ctx.fillStyle = blockFillColor;
                                            ctx.fillRect(((blockX + characterSpriteXCoord) * blockSizeInPixels) + positionFloatingPointLeftovers[0], blockYCoord, blockSizeInPixels, blockSizeInPixels);
                                            ctx.fillStyle = previousFillColor;
                                            distanceFromTopSolidBlock++;
                                        }
                                    }
                                    distanceFromTopSolidBlock++;
                                }
                            }
                        }
                    } catch(e) {
                    }
                    if (gridDebugMode) {
                        ctx.strokeStyle = '#ffb900';
                        ctx.beginPath();
                        ctx.moveTo((blockX + characterSpriteXCoord) * blockSizeInPixels, 0);
                        ctx.lineTo((blockX + characterSpriteXCoord) * blockSizeInPixels, screen.height);
                        ctx.stroke();
                        for (blockY = 0 + positionFloatingPointLeftovers[1];blockY <= maxAmountOfBlocksOnYAxis;blockY++) {
                            ctx.beginPath();
                            ctx.moveTo(0, (blockY * blockSizeInPixels));
                            ctx.lineTo(screen.width, blockY * blockSizeInPixels);
                            ctx.stroke();
                        }
                    }
                }
                ctx.globalAlpha = 1; //draw spirites above here
                if (showCharactersOnScreen) {
                    characterSpriteXCoord = (maxAmountOfBlocksOnXAxis / 2) * blockSizeInPixels;
                    characterSpriteYCoord = (Math.floor(maxAmountOfBlocksOnYAxis / 2) - 2) * blockSizeInPixels;
                    characterSpriteXOffset = blockSizeInPixels * 0.125;
                    characterSpriteYOffset = (blockSizeInPixels * 2) * 0.25;
                    characterSpriteSize = [blockSizeInPixels * 0.75, (blockSizeInPixels * 2) * 0.75];
                    ctx.drawImage(sprites['character'], characterSpriteXCoord + characterSpriteXOffset, characterSpriteYCoord + characterSpriteYOffset, characterSpriteSize[0], characterSpriteSize[1]);
                }
                if (infoDebugMode) {
                    debugItems = [
                        String('POSITION: ' + String(gameData['playerData']['position'])),
                        String('VELOCITY: ' + String(gameData['playerData']['velocities']['x']) + ',' + String(gameData['playerData']['velocities']['y'])),
                        String('TOUCHING-BLOCK: ' + String(getIsTouchingBlock())),
                        String('CURRENT-LOOP-START: ' + String(startTime)),
                        String('PREVIOUS-LOOP-END: ' + String(endTime)),
                        String('LOOP-START-TO-END-TIME: ' + String(lastFps))
                    ];
                    for (i = 0;i < debugItems.length;i++) {
                        ctx.fillStyle = 'black';
                        ctx.font = String((blockSizeInPixels / 2)) + 'px __local__pixelsplitter__';
                        ctx.fillText(String(debugItems[i]), 0, (blockSizeInPixels / 2) + ((blockSizeInPixels / 2) * i));
                    }
                }
                if (showCrosshairOnScreen) {
                    ctx.drawImage(sprites['crosshair'], mouseCoords[0] - (blockSizeInPixels / 2), mouseCoords[1] - (blockSizeInPixels / 2), blockSizeInPixels, blockSizeInPixels);
                    selectionIndicatorCoords = [
                        blockSizeInPixels * (Math.floor(mouseCoords[0] / blockSizeInPixels) - positionFloatingPointLeftovers[0]),
                        blockSizeInPixels * (Math.floor(mouseCoords[1] / blockSizeInPixels) + positionFloatingPointLeftovers[1]),
                    ];
                    ctx.drawImage(sprites['selectionindicator'], selectionIndicatorCoords[0], selectionIndicatorCoords[1], blockSizeInPixels, blockSizeInPixels);
                }
                inventoryKeys = Object.keys(inventory['items']);
                inventorySlotSize = blockSizeInPixels * 1.5;
                if (showInventoryOnScreen) {
                    for (slot = 0;slot < inventoryKeys.length;slot++) {
                        ctx.drawImage(sprites['inventoryslot'], canvas.width - (inventorySlotSize * (slot + 2)), inventorySlotSize, inventorySlotSize, inventorySlotSize);
                        ctx.drawImage(sprites[inventoryKeys[slot]], canvas.width - (inventorySlotSize * (slot + 2)) + ((inventorySlotSize / 100) * 16), inventorySlotSize + ((inventorySlotSize / 100) * 16), inventorySlotSize / 1.5, inventorySlotSize / 1.5);
                        if (slot == inventory['selectedSlot']) {
                            ctx.drawImage(sprites['inventoryslotselected'], canvas.width - (inventorySlotSize * (slot + 2)), inventorySlotSize, inventorySlotSize, inventorySlotSize);
                        }
                        ctx.fillStyle = 'white';
                        ctx.font = String((blockSizeInPixels / 3)) + 'px __local__pixelsplitter__';
                        ctx.fillText(String(inventory['items'][inventoryKeys[slot]]), canvas.width - (inventorySlotSize * (slot + 2)), inventorySlotSize + (blockSizeInPixels / 3))
                    }
                }
                if (gameScreenMode == 'ingame') {
                    isTouchingBlock = getIsTouchingBlock();
                    if (gameData['playerData']['velocities']['x'] > 0.2) {
                        gameData['playerData']['velocities']['x'] -= 0.1;
                    } else if (gameData['playerData']['velocities']['x'] < -0.2) {
                        gameData['playerData']['velocities']['x'] += 0.1;
                    } else {
                        gameData['playerData']['velocities']['x'] = 0;
                    }
                    if (!isTouchingBlock) {
                        if (Math.abs(gameData['playerData']['velocities']['y']) < 0.5) {
                            gameData['playerData']['velocities']['y'] -= 0.005;
                        }
                    }
                    if (isTouchingBlock) {
                        gameData['playerData']['velocities']['y'] = 0;
                        gameData['playerData']['position'][1] = getTouchingBlockCoord();
                    }
                    if (isTouchingBlock && getTouchingBlockCoord() < getMaxBlockYCoord()) {
                        gameData['playerData']['position'][1] = getTouchingBlockCoord() + 1;
                    }
                    gameData['playerData']['position'][0] += gameData['playerData']['velocities']['x'];
                    gameData['playerData']['position'][1] += gameData['playerData']['velocities']['y'];
                    if (cursorEventHandled['handled'] == false) {
                        position = cursorEventHandled['position'];
                        positionOnMap = [position[0], position[1]];
                        positionOnMap[0] = Math.floor(positionOnMap[0] / blockSizeInPixels) + Math.ceil(gameData['playerData']['position'][0]) - Math.ceil(maxAmountOfBlocksOnXAxis / 2);
                        positionOnMap[1] = Math.floor(positionOnMap[1] / blockSizeInPixels) - Math.floor(gameData['playerData']['position'][1]) - Math.floor(maxAmountOfBlocksOnYAxis / 2);
                        positionOnMap[1] = -positionOnMap[1];
                        if (cursorEventHandled['button'] == 'left') {
                            if (positionOnMap[0] >= gameData['boundaryData']['xLeftBoundary'] && positionOnMap[0] <= gameData['boundaryData']['xRightBoundary'] && inventory['items'][Object.keys(inventory['items'])[inventory['selectedSlot']]] > 0) {
                                gameData['terrainData'][positionOnMap[0]]['blockData'][String(positionOnMap[1])] = {
                                    'blockType':Object.keys(inventory['items'])[inventory['selectedSlot']],
                                    'isSolid':true
                                };
                                inventory['items'][Object.keys(inventory['items'])[inventory['selectedSlot']]] -= 1;
                            }
                        }
                        if (cursorEventHandled['button'] == 'right') {
                            try {
                                inventory['items'][gameData['terrainData'][positionOnMap[0]]['blockData'][String(positionOnMap[1])]['blockType']] += 1;
                                if (isNaN(inventory['items'][gameData['terrainData'][positionOnMap[0]]['blockData'][String(positionOnMap[1])]['blockType']])) {
                                    inventory['items'][gameData['terrainData'][positionOnMap[0]]['blockData'][String(positionOnMap[1])]['blockType']] = 1;
                                }
                                delete gameData['terrainData'][positionOnMap[0]]['blockData'][String(positionOnMap[1])]
                            } catch (e) {
                            }
                        }
                        cursorEventHandled['handled'] = true;
                    }
                } else if (gameScreenMode == 'loadingterraingen') {
                    terrainData = Object.keys(gameData['terrainData']);
                    prevoiusGroundLevel = 0;
                    try {
                        blockHeightsForMaxCoord = gameData['terrainData'];
                        blockHeightsForMaxCoord = Object.keys(blockHeightsForMaxCoord);
                        tmpList1 = [];
                        for (key = 0;key < blockHeightsForMaxCoord.length;key++) {
                            tmpList1.push(parseInt(blockHeightsForMaxCoord[key]));
                        }
                        blockHeightsForMaxCoord = Math.max.apply(null, tmpList1);
                        columnData = Object.keys(gameData['terrainData'][blockHeightsForMaxCoord]['blockData']);
                        tmpList2 = [];
                        for (key = 0;key < columnData.length;key++) {
                            tmpList2.push(parseInt(columnData[key]));
                        }
                        prevoiusGroundLevel = Math.max.apply(null, tmpList2);
                    } catch (e) {
                        prevoiusGroundLevel = 0;
                    }
                    gameData['terrainData'] = generateTerrainChunk(
                        terrainGenProgress, //minXCoord
                        terrainGenProgress + 5, //maxXCoord
                        gameData['boundaryData']['yTopBoundary'], //maxHeight 
                        gameData['boundaryData']['yBottomBoundary'], //minHeight
                        gameData['boundaryData']['xLeftBoundary'], //worldXMinBorder
                        gameData['boundaryData']['xRightBoundary'], //worldXMaxBorder
                        prevoiusGroundLevel, //prevoiusGroundLevel
                        gameData['terrainData'], //previousTerrainData
                        gameData['boundaryData']['generationMaxHeight'], //maxMountainHeight 
                        gameData['boundaryData']['generationMinHeight'] //minValleyDepth
                    );
                    previousFillStyle = ctx.fillStyle;
                    ctx.fillStyle = '#5c5c5c';
                    loadingScreenBarSize = [canvas.width / 2, canvas.height / 15];
                    rectCoords = [0, 0, 0, 0];
                    rectCoords[0] = ((canvas.width - loadingScreenBarSize[0]) / 2)
                    rectCoords[1] = ((canvas.height - loadingScreenBarSize[1]) / 2)
                    rectCoords[2] = loadingScreenBarSize[0];
                    rectCoords[3] = loadingScreenBarSize[1];
                    ctx.fillRect(rectCoords[0], rectCoords[1], rectCoords[2], rectCoords[3]);
                    innerRectCoords = [rectCoords[0] + 10, rectCoords[1] + 10, ((rectCoords[2] - 20) * (terrainGenProgress / gameData['boundaryData']['xRightBoundary'])), rectCoords[3] - 20];
                    ctx.fillStyle = 'black'
                    ctx.fillRect(innerRectCoords[0], innerRectCoords[1], innerRectCoords[2], innerRectCoords[3]);
                    ctx.fillStyle = 'white';
                    ctx.font = String(loadingScreenBarSize[1] / 3) + 'px __local__pixelsplitter__';
                    ctx.fillText(('Loading game...(' + String(terrainGenProgress) + '/' + String(gameData['boundaryData']['xRightBoundary']) + ')'), innerRectCoords[0], innerRectCoords[1] + (loadingScreenBarSize[1] / 3));
                    ctx.fillStyle = previousFillStyle;
                    terrainGenProgress++;
                    if (terrainGenProgress >= gameData['boundaryData']['xRightBoundary']) {
                        gameScreenMode = 'ingame';
                    }
                } else if (gameScreenMode.split(':')[0] == 'menu') {
                    previousFillStyle = ctx.fillStyle;
                    ctx.fillStyle = 'rgba(114, 114, 114, 0.9)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    menuData['currentSelectedMenuButton'] = parseInt(gameScreenMode.split(':')[1]);
                    ctx.fillStyle = '#274e2C';
                    ctx.font = '20px __local__pixelsplitter__';
                    ctx.fillText('Use the up and down arrow keys to navigate the menu.', 0, 20);
                    for (menuButton = 0;menuButton < menuData['menuItems'].length;menuButton++) {
                        menuButtonSpritePath = sprites[menuData['menuItemData'][menuData['menuItems'][menuButton]]['spriteData']];
                        menuButtonSize = menuData['menuButtonSize'];
                        ctx.drawImage(menuButtonSpritePath, 100, 100 + ((menuButtonSize[1] + 10) * menuButton), menuButtonSize[0], menuButtonSize[1]);
                        if (menuButton == menuData['currentSelectedMenuButton']) {
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.25)';
                            ctx.fillRect(100, 100 + ((menuButtonSize[1] + 10) * menuButton), menuButtonSize[0], menuButtonSize[1]);
                            menuPanelInfo = menuData['menuItemData'][menuData['menuItems'][menuButton]]['panelInfo']
                            ctx.fillStyle = '#274e2C';
                            fontSize = (canvas.height - 100) / menuPanelInfo.length;
                            if (fontSize > 30) {
                                fontSize = 30;
                            }
                            ctx.font = String(fontSize) + 'px __local__pixelsplitter__';
                            for (line = 0;line < menuPanelInfo.length;line++) {
                                ctx.fillText(String(menuPanelInfo[line]), 100 + menuButtonSize[0] + 100, ((line + 1) * fontSize) + 100);
                            }
                        }
                    }
                    ctx.fillStyle = previousFillStyle;
                }
                endTime = performance.now();
                lastFps = (endTime - startTime) / 1000;
                //running = false;
                if (running) {
                    window.requestAnimationFrame(drawLoop);
                } else {   
                    console.log('Main draw loop ended.');
                }
            }
            window.requestAnimationFrame(drawLoop);
        </script>
    </body>
</html>