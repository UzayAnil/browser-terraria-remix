<!--
    TODO:
        1.] Add an inventory section.
        2.] Add a way for the user to save screenshots using the REIMG script on this thread ( https://stackoverflow.com/questions/10673122/how-to-save-canvas-as-an-image-with-canvas-todataurl )
        3.] Make it so that the trees are randomly rotated, or are different sprites for randomization.
        4.] Add buttons so that its playable on mobile devices.
-->
<!--
    CONTROLS:
        W: Jump
        A: Move left
        D: Move right
        R: Reset the player to the coordinates [0,0]
        [: Toggle the text debug
        ]: Toggle the grid line debug
-->
<!DOCTYPE HTML>
<html lang = 'en'>
    <head>
        <meta charset = 'utf-8'/>
        <title>Terraria Browser Remix</title>
        <style>
            @font-face{font-family:__local__pixelsplitter__;src:url('./utils/fonts/pixelsplitter.ttf');}
            body{font-family:__local__pixelsplitter__;background-color:white;}
            .daylightAffectedSprite{background-color:black;opacity:1;}
            .gameBlockSprite{width:20px;height:20px;}
            .gameCharacterSprite{width:20px;height:40px;}
            #gamecanvas{background-color:#91f8ff;position:absolute;top:0px;left:0px;width:100%;height:100%;}
            .hiddenImage{display:none;}
        </style>
    </head>
    <body onkeydown = 'handleKeyDown(event.keyCode);'>
        <img src = './utils/ingame-images/character-sprite.png' id = 'sprites.charactersprite' class = 'daylightAffectedSprite gameCharacterSprite hiddenImage'/>
        <img src = './utils/ingame-images/dirt-block.png' id = 'sprites.dirtblocksprite' class = 'daylightAffectedSprite gameBlockSprite hiddenImage'/>
        <img src = './utils/ingame-images/error-block.png' id = 'sprites.errorblocksprite' class = 'daylightAffectedSprite gameBlockSprite hiddenImage'/>
        <img src = './utils/ingame-images/grass-block.png' id = 'sprites.grassblocksprite' class = 'daylightAffectedSprite gameBlockSprite hiddenImage'/>
        <img src = './utils/ingame-images/stone-block.png' id = 'sprites.stoneblocksprite' class = 'daylightAffectedSprite gameBlockSprite hiddenImage'/>
        <img src = './utils/ingame-images/grass-overlay.png' id = 'sprites.grassoverlaysprite' class = 'daylightAffectedSprite gameBlockSprite hiddenImage'/>
        <img src = './utils/ingame-images/crosshair.png' id = 'sprites.crosshair' class = 'hiddenImage'/>
        <img src = './utils/ingame-images/tree-sprite.png' id = 'sprites.treesprite1' class = 'daylightAffectedSprite hiddenImage'/>
        <img src = './utils/ingame-images/shrubbery-overlay.png' id = 'sprites.shrubberyoverlaysprite' class = 'daylightAffectedSprite gameBlockSprite hiddenImage'/>
        <img src = './utils/ingame-images/startscreen-art.png' id = 'sprites.startscreenart' class = 'hiddenImage'/>
        <canvas id = 'gamecanvas'><p>Error showing canvas.</p></canvas>
        <script>
            console.log('Press the "[" button to toggle the debug overlay.')
            function getRandomInt(min, max) {
                return Math.floor(Math.random() * (max - min + 1) + min);
            }
            function getTouchingBlockCoord() {
                return yCoordinateTouching = Math.floor(gameData['playerData']['position'][1]);
            }
            function getIsTouchingBlock() {
                var isTouchingBlock = false;
                var yCoordinateTouching = Math.floor(gameData['playerData']['position'][1]);
                try {
                    blockData = gameData['terrainData'][Math.floor(gameData['playerData']['position'][0])]['blockData'][yCoordinateTouching];
                    if (blockData != undefined && blockData['isSolid'] == true) {
                        isTouchingBlock = true;
                    }
                } catch (e) {
                }
                return isTouchingBlock;
            }
            function getMaxBlockYCoord() {
                var maxYCoord = 0;
                var blocksInRow = gameData['terrainData'][Math.floor(gameData['playerData']['position'][0])]['blockData'];
                var blocksInRowKeys = Object.keys(blocksInRow);
                var blocksInRowKeysInts = [];
                for (i = 0;i < blocksInRowKeys.length;i++) {
                    if (blocksInRow[blocksInRowKeys[i]]['isSolid']) {
                        blocksInRowKeysInts.push(parseInt(blocksInRowKeys[i]));
                    }
                }
                maxYCoord = Math.max.apply(null, blocksInRowKeysInts);
                return maxYCoord;
            }
            function getMaxBlockYCoordForGivenXCoord(xCoord) {
                var maxYCoord = 0;
                var blocksInRow = gameData['terrainData'][Math.floor(xCoord)]['blockData'];
                var blocksInRowKeys = Object.keys(blocksInRow);
                var blocksInRowKeysInts = [];
                for (i = 0;i < blocksInRowKeys.length;i++) {
                    if (blocksInRow[blocksInRowKeys[i]]['isSolid']) {
                        blocksInRowKeysInts.push(parseInt(blocksInRowKeys[i]));
                    }
                }
                maxYCoord = Math.max.apply(null, blocksInRowKeysInts);
                return maxYCoord;
            }
            function handleKeyDown(keyCode) {
                if (gameScreenMode == 'ingame') {
                    isTouchingBlock = getIsTouchingBlock();
                    if (keyCode == 68) {
                        gameData['playerData']['position'][0] += 0.5;
                    } else if (keyCode == 65) {
                        gameData['playerData']['position'][0] -= 0.5;
                    } else if (keyCode == 87 && isTouchingBlock) {
                        gameData['playerData']['position'][1] += 2;
                    } else if (keyCode == 219) {
                        infoDebugMode = !infoDebugMode;
                    } else if (keyCode == 221) {
                        gridDebugMode = !gridDebugMode;
                    } else if (keyCode == 82) {
                        gameData['playerData']['position'] = [0, 0];
                    }
                } else if (gameScreenMode == 'start') {
                    if (keyCode == startScreenAssets['startscreenbg']['keypresstostart']['keyCode']) {
                        gameScreenMode = 'ingame';
                    }
                }
            }
            function toggleScreenshotMode1() {
                showCharactersOnScreen = !showCharactersOnScreen;
                showCrosshairOnScreen = !showCrosshairOnScreen;
            }
            function generateTerrainChunk(minXCoord, maxXCoord, maxHeight, minHeight, worldXMinBorder, worldXMaxBorder, prevoiusGroundLevel, previousTerrainData) {
                var groundLevel = prevoiusGroundLevel;
                for (xCoord = minXCoord;xCoord <= maxXCoord;xCoord++) {
                    if (!(xCoord in previousTerrainData) && xCoord >= worldXMinBorder && xCoord <= worldXMaxBorder) {
                        groundLevel = getRandomInt(groundLevel - 1, groundLevel + 1)
                        rowData = {
                            'maxHeight':0,
                            'blockData':{
                            }
                        };
                        rowData['maxHeight'] = parseInt(maxHeight);
                        for (yCoord = maxHeight;yCoord >= minHeight;yCoord--) {
                            if (groundLevel > maxHeight) {
                                groundLevel = maxHeight;
                            } else if (groundLevel < minHeight) {
                                groundLevel = minHeight;
                            }
                            distanceFromGroundLevel = groundLevel - yCoord;
                            isSolidBlock = true;
                            individualBlockData = {
                                'blockType':'errorblock',
                                'isSolid':true
                            }
                            if (yCoord <= groundLevel) {
                                if (distanceFromGroundLevel == 0) {
                                    blockType = 'grassblock';                                
                                } else if (distanceFromGroundLevel < getRandomInt(2, 5)) {
                                    blockType = 'dirtblock';
                                } else {
                                    blockType = 'stoneblock';
                                }
                                individualBlockData['blockType'] = blockType;
                                individualBlockData['isSolid'] = isSolidBlock;
                                rowData['blockData'][yCoord] = individualBlockData;
                            } else {
                                if (distanceFromGroundLevel == -1 && getRandomInt(0, 3) == 1) {
                                    blockType = 'grassoverlay';
                                    isSolidBlock = false;
                                    individualBlockData['blockType'] = blockType;
                                    individualBlockData['isSolid'] = isSolidBlock;
                                    rowData['blockData'][yCoord] = individualBlockData;
                                } else if (distanceFromGroundLevel == -1 && getRandomInt(0, 6) == 1) {
                                    blockType = 'shrubbery';
                                    isSolidBlock = false;
                                    individualBlockData['blockType'] = blockType;
                                    individualBlockData['isSolid'] = isSolidBlock;
                                    rowData['blockData'][yCoord] = individualBlockData;
                                } else if (distanceFromGroundLevel == -1 && getRandomInt(0, 6) == 1) {
                                    blockType = 'tree1';
                                    isSolidBlock = false;
                                    individualBlockData['blockType'] = blockType;
                                    individualBlockData['isSolid'] = isSolidBlock;
                                    rowData['blockData'][yCoord] = individualBlockData;
                                }
                            }
                        }
                        previousTerrainData[xCoord] = rowData;
                    }
                }
                return previousTerrainData;
            }
            var shaderMode = 'blocky-depth-shaders-1';
            var shaderPresets = {
                'blocky-depth-shaders-1':{
                    'maxLightPenetrationDepth':5,
                    'minDarkness':0.95,
                }
            };
            var showCrosshairOnScreen = true;
            var showCharactersOnScreen = true;
            var gameScreenMode = 'ingame';
            var gridDebugMode = false; //disable for public release
            var infoDebugMode = false; //disable for public release
            var darknessLevel = 0;
            var canvas = document.getElementById('gamecanvas');
            var ctx = canvas.getContext('2d');
            var sprites = {
                'character':document.getElementById('sprites.charactersprite'),
                'dirtblock':document.getElementById('sprites.dirtblocksprite'),
                'errorblock':document.getElementById('sprites.errorblocksprite'),
                'grassblock':document.getElementById('sprites.grassblocksprite'),
                'stoneblock':document.getElementById('sprites.stoneblocksprite'),
                'grassoverlay':document.getElementById('sprites.grassoverlaysprite'),
                'crosshair':document.getElementById('sprites.crosshair'),
                'tree1':document.getElementById('sprites.treesprite1'),
                'shrubbery':document.getElementById('sprites.shrubberyoverlaysprite'),
            };
            var startScreenAssets = {
                'startscreenbg':{
                    'image':document.getElementById('sprites.startscreenart'),
                    'dimensions':[1800, 1800],
                    'keypresstostart':{
                        'keyCode':83
                    }
                }
            };
            var canvasBGColor = 'rgba(0, 0, 0, 1)';
            var blockSizeInPixels = 40;
            var running = true;
            var gameData = {
                'meta':{
                    'version':[0, 0, 1],
                },'terrainData':{
                },'playerData':{
                    'velocities':{
                        'x':0,
                        'y':0
                    },
                    'position':[0, 0]
                }, 'boundaryData':{
                    'xLeftBoundary':0,
                    'xRightBoundary':500,
                    'yTopBoundary':30,
                    'yBottomBoundary':-30
                }
            };
            var mouseCoords = [Math.round(canvas.width / 2), Math.round(canvas.height / 2)];
            ctx.canvas.addEventListener('mousemove', function(event){
                mouseCoords = [event.clientX - ctx.canvas.offsetLeft, event.clientY - ctx.canvas.offsetTop];
            });
            var lastFps = 0;
            function drawLoop() {
                startTime = performance.now();
                canvas.width = canvas.clientWidth;
                canvas.height = canvas.clientHeight;
                canvasBGColor = 'rgba(0, 0, 0, ' + darknessLevel + ')';
                ctx.fillStyle = canvasBGColor;
                ctx.imageSmoothingEnabled = false;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                if (gameScreenMode == 'ingame') {
                    maxAmountOfBlocksOnXAxis = Math.floor(canvas.width / blockSizeInPixels) + 1;
                    maxAmountOfBlocksOnYAxis = Math.floor(canvas.height / blockSizeInPixels) + 1;
                    alphaDarkness = 1 - darknessLevel;
                    alphaDarkness = alphaDarkness + (darknessLevel / 2);
                    ctx.globalAlpha = alphaDarkness; //draw sprites below here
                    //BELOW HERE IS A MESS - IM SORRY IF YOU ARE THE ONE WHO WAS CALLED TO REWRITE IT
                    if (!(Math.floor(gameData['playerData']['position'][0]) + maxAmountOfBlocksOnXAxis in gameData['terrainData'])) {
                        terrainData = Object.keys(gameData['terrainData']);
                        try {
                            blockHeightsForMaxCoord = gameData['terrainData'];
                            blockHeightsForMaxCoord = Object.keys(blockHeightsForMaxCoord);
                            tmpList1 = [];
                            for (key = 0;key < blockHeightsForMaxCoord.length;key++) {
                                tmpList1.push(parseInt(blockHeightsForMaxCoord[key]));
                            }
                            blockHeightsForMaxCoord = Math.max.apply(null, tmpList1);
                            columnData = Object.keys(gameData['terrainData'][blockHeightsForMaxCoord]['blockData']);
                            tmpList2 = [];
                            for (key = 0;key < columnData.length;key++) {
                                tmpList2.push(parseInt(columnData[key]));
                            }
                            prevoiusGroundLevel = Math.max.apply(null, tmpList2);
                        } catch (e) {
                            prevoiusGroundLevel = 0;
                        }
                        gameData['terrainData'] = generateTerrainChunk(Math.floor(gameData['playerData']['position'][0]), Math.floor(gameData['playerData']['position'][0]) + maxAmountOfBlocksOnXAxis, gameData['boundaryData']['yTopBoundary'], gameData['boundaryData']['yBottomBoundary'], gameData['boundaryData']['xLeftBoundary'], gameData['boundaryData']['xRightBoundary'], prevoiusGroundLevel, gameData['terrainData']);
                    } 
                    //ABOVE HERE IS A MESS - IM SORRY IF YOU ARE THE ONE WHO WAS CALLED TO REWRITE IT
                    positionFloatingPointLeftovers = [(gameData['playerData']['position'][0] - Math.floor(gameData['playerData']['position'][0])), (gameData['playerData']['position'][1] - Math.floor(gameData['playerData']['position'][1]))];
                    characterSpriteXCoord = Math.ceil((maxAmountOfBlocksOnXAxis / 2));
                    for (blockX = -characterSpriteXCoord + positionFloatingPointLeftovers[0] - 1;blockX < maxAmountOfBlocksOnXAxis - characterSpriteXCoord;blockX++) {
                        try {
                            rowData = gameData['terrainData'][Math.floor(blockX + gameData['playerData']['position'][0])];
                            drewCharacter = false;
                            if (rowData != undefined) {
                                for (YCoord in rowData['blockData']) {
                                    centerYCoord = Math.floor(maxAmountOfBlocksOnYAxis / 2) * blockSizeInPixels;
                                    individualData = rowData['blockData'][YCoord]['blockType'];
                                    blockYCoord = (centerYCoord - (YCoord * blockSizeInPixels)) + (gameData['playerData']['position'][1] * blockSizeInPixels);
                                    if (blockYCoord < maxAmountOfBlocksOnYAxis * blockSizeInPixels) {
                                        spriteName = sprites[individualData];
                                        if (spriteName == sprites['tree1']) {
                                            ctx.drawImage(spriteName, (((blockX + characterSpriteXCoord) * blockSizeInPixels) + positionFloatingPointLeftovers[0]) - blockSizeInPixels, blockYCoord - (blockSizeInPixels * 3), (blockSizeInPixels * 3), (blockSizeInPixels * 4));
                                        } else {
                                            ctx.drawImage(spriteName, ((blockX + characterSpriteXCoord) * blockSizeInPixels) + positionFloatingPointLeftovers[0], blockYCoord, blockSizeInPixels, blockSizeInPixels);
                                            if (shaderMode == 'blocky-depth-shaders-1' && rowData['blockData'][YCoord]['isSolid']) {
                                                distanceFromTopSolidBlock = getMaxBlockYCoordForGivenXCoord(blockX + gameData['playerData']['position'][0]) - YCoord;
                                                previousFillColor = ctx.fillStyle;
                                                depthDarkness = 0;
                                                shaderData = shaderPresets[shaderMode];
                                                darknessStep = shaderData['minDarkness'] / shaderData['maxLightPenetrationDepth'];
                                                if (distanceFromTopSolidBlock <= shaderData['maxLightPenetrationDepth']) {
                                                    depthDarkness = darknessStep * distanceFromTopSolidBlock;
                                                } else if (distanceFromTopSolidBlock > shaderData['maxLightPenetrationDepth']) {
                                                    depthDarkness = shaderData['minDarkness'];
                                                }
                                                blockFillColor = 'rgba(0, 0, 0, ' + String(depthDarkness) + ')'
                                                ctx.fillStyle = blockFillColor;
                                                ctx.fillRect(((blockX + characterSpriteXCoord) * blockSizeInPixels) + positionFloatingPointLeftovers[0], blockYCoord, blockSizeInPixels, blockSizeInPixels);
                                                ctx.fillStyle = previousFillColor;
                                                distanceFromTopSolidBlock++;
                                            }
                                        }
                                        distanceFromTopSolidBlock++;
                                    }
                                }
                            }
                        } catch(e) {
                        }
                        if (gridDebugMode) {
                            ctx.strokeStyle = '#ffb900';
                            ctx.beginPath();
                            ctx.moveTo((blockX + characterSpriteXCoord) * blockSizeInPixels, 0);
                            ctx.lineTo((blockX + characterSpriteXCoord) * blockSizeInPixels, screen.height);
                            ctx.stroke();
                            for (blockY = 0 + positionFloatingPointLeftovers[1];blockY <= maxAmountOfBlocksOnYAxis;blockY++) {
                                ctx.beginPath();
                                ctx.moveTo(0, (blockY * blockSizeInPixels));
                                ctx.lineTo(screen.width, blockY * blockSizeInPixels);
                                ctx.stroke();
                            }
                        }
                    }
                    ctx.globalAlpha = 1; //draw spirites above here
                    if (showCharactersOnScreen) {
                        characterSpriteXCoord = (maxAmountOfBlocksOnXAxis / 2) * blockSizeInPixels;
                        characterSpriteYCoord = (Math.floor(maxAmountOfBlocksOnYAxis / 2) - 2) * blockSizeInPixels;
                        ctx.drawImage(sprites['character'], characterSpriteXCoord, characterSpriteYCoord, blockSizeInPixels, blockSizeInPixels * 2);
                    }
                    if (infoDebugMode) {
                        debugItems = [
                            String('POSITION: ' + String(gameData['playerData']['position'])),
                            String('VELOCITY: ' + String(gameData['playerData']['velocities']['x']) + ',' + String(gameData['playerData']['velocities']['y'])),
                            String('TOUCHING-BLOCK: ' + String(getIsTouchingBlock())),
                            String('CURRENT-LOOP-START: ' + String(startTime)),
                            String('PREVIOUS-LOOP-END: ' + String(endTime)),
                            String('LOOP-START-TO-END-TIME: ' + String(lastFps))
                        ];
                        for (i = 0;i < debugItems.length;i++) {
                            ctx.fillStyle = 'black';
                            ctx.font = String((blockSizeInPixels / 2)) + 'px __local__pixelsplitter__';
                            ctx.fillText(String(debugItems[i]), 0, (blockSizeInPixels / 2) + ((blockSizeInPixels / 2) * i));
                        }
                    }
                    if (showCrosshairOnScreen) {
                        ctx.drawImage(sprites['crosshair'], mouseCoords[0] - (blockSizeInPixels / 2), mouseCoords[1] - (blockSizeInPixels / 2), blockSizeInPixels, blockSizeInPixels);
                    }
                    isTouchingBlock = getIsTouchingBlock();
                    if (gameData['playerData']['velocities']['x'] > 0.2) {
                        gameData['playerData']['velocities']['x'] -= 0.1;
                    } else if (gameData['playerData']['velocities']['x'] < -0.2) {
                        gameData['playerData']['velocities']['x'] += 0.1;
                    } else {
                        gameData['playerData']['velocities']['x'] = 0;
                    }
                    if (!isTouchingBlock) {
                        if (Math.abs(gameData['playerData']['velocities']['y']) < 0.5) {
                            gameData['playerData']['velocities']['y'] -= 0.005;
                        }
                    }
                    if (isTouchingBlock) {
                        gameData['playerData']['velocities']['y'] = 0;
                        gameData['playerData']['position'][1] = getTouchingBlockCoord();
                    }
                    if (isTouchingBlock && getTouchingBlockCoord() < getMaxBlockYCoord()) {
                        gameData['playerData']['position'][1] = getTouchingBlockCoord() + 1;
                    }
                    gameData['playerData']['position'][0] += gameData['playerData']['velocities']['x'];
                    gameData['playerData']['position'][1] += gameData['playerData']['velocities']['y'];
                    endTime = performance.now();
                    lastFps = (endTime - startTime) / 1000;
                } else if (gameScreenMode == 'start') {
                    startScreenImageCoords = [0, 0];
                    startScreenImageSize = startScreenAssets['startscreenbg']['dimensions'];
                    screenAspectRatio = startScreenImageSize[0] / startScreenImageSize[1];
                    startScreenImageSize[1] = canvas.height;
                    startScreenImageSize[0] = canvas.height * screenAspectRatio;
                    startScreenImageCoords[0] = (canvas.width - startScreenImageSize[0]) / 2;
                    ctx.drawImage(startScreenAssets['startscreenbg']['image'], startScreenImageCoords[0], startScreenImageCoords[1], startScreenImageSize[0], startScreenImageSize[1]);
                } else {
                    gameScreenMode = 'start';
                }
                //running = false;
                if (running) {
                    window.requestAnimationFrame(drawLoop);
                } else {   
                    console.log('Main draw loop ended.');
                }
            }
            window.requestAnimationFrame(drawLoop);
        </script>
    </body>
</html>